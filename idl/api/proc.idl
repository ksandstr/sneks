
#ifndef __API_PROC_IDL__
#define __API_PROC_IDL__

#include <muidl.idl>
#include <l4x2.idl>
#include <posixlike.idl>


module Sneks {

[StubPrefix(__proc), IfaceLabel(0xe801)]
interface Proc
{
	typedef string<512> pathbuf;
	typedef string<4096> argbuf; /* substrings separated by 0x1e (RS). */

	[Label(0x1234)]		/* (provisional) */
	void create_thread([MR(1)] out L4X2::ThreadId tid)
		raises(Posix::Errno);

	/* not replied to if successful and @tid is the caller, even if the
	 * message was propagated. @utcb_addr is the raw local form of @tid
	 * as available to the caller.
	 */
	void remove_thread(in L4X2::ThreadId tid, in L4X2::word utcb_addr)
		raises(Posix::Errno, muidl::NoReply);

	/* spawns a child process without the expense of fork+exec, or from a
	 * systask such as to launch userspace helpers or /sbin/init. constructs
	 * the argument and environment regions using @args and @envs provided;
	 * the child process need not care whether it was loaded due to exec or
	 * spawn. this interface is different from, and more low-level than, the
	 * standard posix_spawn(3); the two should not be confused.
	 *
	 * since muidl is broken wrt sequences of structs, we pass the fdlist
	 * structure's components in parallel. the length of the resulting fdlist
	 * is the length of the shortest component sequence. this kludge will go
	 * away once muidl gets unfucked.
	 *
	 * return value is the new process ID.
	 */
	typedef sequence<L4X2::ThreadId, 1024> fd_servs;
	typedef sequence<L4X2::word, 1024> fd_cookies;
	typedef sequence<long, 1024> fd_fds;
	unsigned short spawn(
		in pathbuf filename, in argbuf args, in argbuf envs,
		in fd_servs servs, in fd_cookies cookies, in fd_fds fds)
			raises(Posix::Errno);

	/* like POSIX kill(2) */
	void kill(in long pid, in long sig)
		raises(muidl::NoReply, Posix::Errno);

	/* POSIX exit(3). since there's no waitpid(2), @status goes nowhere. */
	void exit(in long status)
		raises(muidl::NoReply);

	/* like Linux waitid(2), but contents of siginfo_t are passed explicitly.
	 * siginfo_t fields that Linux defines but which aren't specified in the
	 * waitid(2) manpage aren't supported. values of idtype and the si_*
	 * return values are defined in <sneks/process.h>.
	 */
	void wait(
		[MR(1)] out long si_pid, [MR(2)] out long si_uid,
		[MR(3)] out long si_signo, [MR(4)] out long si_status,
		[MR(5)] out long si_code,
		in long idtype, in long id, in long options)
			raises(muidl::NoReply, Posix::Errno);

	/* like POSIX fork(2), but leaves userspace I/O resources up to the
	 * caller. launches a thread in the destination address space according to
	 * @sp and @ip and delivers its global ID in @tid, or raises Posix::Errno
	 * like fork(2) would.
	 */
	void fork(
		out L4X2::ThreadId tid,
		in L4X2::word sp, in L4X2::word ip)
			raises(Posix::Errno);
};


};

#endif
